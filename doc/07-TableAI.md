## 打表器TableAI
* 众子皆胜我必败,破罐破摔可乱走  
* 一子为败我必胜，取此败子  
* 否则必为儿子中有胜有和，取和子才能不犯错

也就是说，为了最小化对手的利益，需要从儿子结点中优先选取败子，其次优先选取和子，最后不得已选择胜子。     

## 打表器输出table.txt的格式
table.txt为小头序的int数组，a[0],a[1],a[2]......
a[0]表示状态，a[1]表示a[0]状态的解法，把a[1]表示成3进制形式，则最末位表示该状态的胜负和三种状态。其余位表示棋盘上每个点是0（和）、1（胜利）或者2（失败）。

### 打表器构图法两种
* 法一：从开始状态进行广度优先搜索，直到搜索到某一方只有1子。  
* 法二：使用3进制法进行状态哈希，更好的方法是组合数哈希，但是那样编程复杂度高。那么棋盘从1变化到1111000000002222(3进制)，在构图过程中，跳过不合理的结点。  
组合数哈希：在两颗吃一颗中，有C(16,8)C(8,4)+C(16,7)C(4,3)+C(16,7)C(3,4)+...种状态。类似于全排列散列，给定一个1110001022000022这样的序列，可以将其映射为一个数字。使用组合数哈希能够节省空间。但是编程复杂度较大，并且可读性差。   

### 按照某个顺序给结点赋值
全部状态构成一张状态图，状态图之间的连接就是着法。  
对于整个状态图，是一个有向图（因为吃子之后无法逆回去）。  
构图的过程中已经把胜负确定了的局面加入到了队列中。构完图之后，就开始处理这个队列。对于队列中的每一个结点，更新它的父节点，告知众位父亲，我的状态是输还是赢（不可能为和，因为队列中不可能有和棋状态）。如果父节点发现自己有败子，则觉得自己必胜，父节点入队；如果父节点发现自己众子皆胜，则自己必败。如此处理队列，直到队列为空。  
那些未被处理的结点必然是和棋状态，它们的着法必然是从儿子中选取任意一个和棋状态，儿子中必然不存在败子（否则自己必胜），也必然存在和子（否则众子皆胜）。

### 打表器产生的数据
* 在丧失战斗力为输、两颗吃一颗规则下，从初始状态出发进行广搜可以达到（2188959 ）结点，这些结点中必胜结点有（1152375）个，必败结点有（653308）个，其余为和棋状态，有（383276）个。   
* 如果一个结点是必胜状态，它至多需要（42）步才能实现胜利。